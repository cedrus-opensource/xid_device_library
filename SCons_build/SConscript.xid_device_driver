#!/usr/bin/env python

import imp
import CedrusSConsHelperFunctions
import CedrusSConsDefaultEnvironments

import os
import sys

Import('env')

# This is silly and just feels wrong to do, frankly. Seems like there should be a better way.
# We're doing this here because inheriting these from SuperLab can be dangerous and this
# seems like an alright idea in general. I just don't know, though.
env.Replace(
CXXFLAGS = [],
LIB_PATH = [],
CCPCHFLAGS = []
)

# should compute a path like: /Users/ematsak/source/xid_device_library
# (it should be where you CLONED the project: git@github.com:cedrus-opensource/xid_device_library.git)
env.SetDefault(XIDLIB_OUTER_REPO_DIR = os.path.abspath(os.getcwd()) + os.path.sep + '..' + os.path.sep )
outer_repo_root_dir = env['XIDLIB_OUTER_REPO_DIR']

# set boost and wx versions. we don't actually use wx here, but some of the helper code relies on it
env['BOOST_VERSION'] = '1_58'
env['BOOST_DIR'] = outer_repo_root_dir + "binaries_boost" + os.path.sep + env['BOOST_VERSION']
env['WX_VERSION'] = 'NONE'
#os.environ['GMOCK'] = outer_repo_root_dir + 'binaries_gtest'

env = CedrusSConsDefaultEnvironments.GetDefaultSetupForCurrentSystemAndCommandLine( env )

if sys.platform == 'win32':
    os.environ['BOOST_ROOT'] = outer_repo_root_dir + 'binaries_boost/install'
if sys.platform == 'darwin':
    os.environ['BOOST'] = outer_repo_root_dir + 'binaries_boost/install'

# Normally we'd go "import CedrusBoost" at the top and be done with it. However, there can
# be complications there when we're running this SConscript as a dependency for a
# different Cedrus project. We're erring on the side of caution and making absolutely sure
# we import our own CedrusBoost module.
cedrusboost_xidlib = imp.load_source('CedrusBoost_xidlib', outer_repo_root_dir + 'scons_helpers/scons/CedrusBoost.py')

boost = cedrusboost_xidlib.CedrusBoostSettings(env)
boost.need_boost_filesystem()
boost.need_boost_system()
boost.need_boost_python()

project_target_name = 'xid_device_driver'

prefix = ''

if env.has_key( 'THE_CEDRUS_XIDON_BUILD' ):
    prefix = '$OBJ_ROOT/xid_device_library/'

inputs = [
    prefix + 'xid_device_driver/xid_con_t.cpp',
    prefix + 'xid_device_driver/xid_con_test_only.cpp',
    prefix + 'xid_device_driver/xid_device_config_t.cpp',
    prefix + 'xid_device_driver/response_mgr.cpp',
    prefix + 'xid_device_driver/xid_glossary.cpp',
    prefix + 'xid_device_driver/xid_device_scanner_t.cpp',
    prefix + 'xid_device_driver/base_device_t.cpp',
    prefix + 'xid_device_driver/device_factory.cpp',
    prefix + 'xid_device_driver/xid_device_t.cpp',
    prefix + 'xid_device_driver/xid2_device.cpp',
    prefix + 'xid_device_driver/stim_tracker_t.cpp',
    prefix + 'xid_device_driver/py_binding.cpp',
]

defines = [ 'CEDRUS_XID_MAKEDLL' ]
cxxflags = []
frameworks = []

include_path = [ prefix + 'scons_helpers/cpp_src/']
lib_path = []

staging_dir = str(env.subst('$STAGING_DIR'))

name_of_pyd = staging_dir + os.path.sep + "xid"
project_target = staging_dir + os.path.sep

python_path = outer_repo_root_dir + 'Python27'

if sys.platform == 'win32':
    lib_dependencies = ['ftd2xx']
    include_path.append( python_path +'/win32/include/' )
    lib_path.append( python_path + '/win32/libs/' )
    env.Install( staging_dir, env.subst('ftd2xx.dll') )
    project_target += project_target_name + ".dll"
    name_of_pyd += ".pyd"

if sys.platform == 'darwin':
    lib_dependencies = ['ftd2xx.1.2.2', 'libpython2.7']
    include_path.append( python_path +'/osx/include/' )
    lib_path.append( python_path +'/osx/libs/' )
    env.Install( staging_dir, env.subst('libftd2xx.1.2.2.dylib') )
    project_target += "lib" + project_target_name + ".dylib"
    name_of_pyd += ".so"

# Clean up potentially outdated versions of the XID Python extension and the test
Execute( Delete(name_of_pyd) )
name_of_test = 'xid_commands.py'
Execute( Delete( staging_dir + os.path.sep + name_of_test ) )

# Install fresh ones by copying the XID library file as XID Python extension and replacing the test.
env.InstallAs( name_of_pyd, project_target )
env.Install( staging_dir, outer_repo_root_dir + 'Tests' + os.path.sep + name_of_test )

linkflags = []

if sys.platform == 'win32':
    linkflags = [ '/SUBSYSTEM:WINDOWS',  '/VERSION:4.5', '/MANIFEST', '/INCREMENTAL', ]

elif sys.platform == 'darwin':
    frameworks = ['CoreFoundation', 'IOKit']

# This will be used in CedrusSConsHelperFunctions
total_complete_staging = []
total_complete_staging += boost.publish_all_libs_to_staging()
env.AppendUnique(CEDRUS_COMPLETE_THIRD_PARTY_STAGING = total_complete_staging)

staged_binary = CedrusSConsHelperFunctions.DeclareSConsSharedLibraryBuild(
    env,
    project_target_name,
    inputs,
    defines,
    include_path,
    cxxflags,
    frameworks,
    lib_dependencies,
    lib_path,
    linkflags
)

# This only serves to let an OSX app know what to include in the app bundle. This could
# be made darwin-only but there isn't really harm in always returning this information.
required_libs_for_copying = list(env['LIBS'])

 # don't actually need to copy dylibs for this one
if 'libpython2.7' in required_libs_for_copying: required_libs_for_copying.remove('libpython2.7')

Return('required_libs_for_copying')
